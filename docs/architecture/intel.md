# EC4X Intel and Fog of War System

## Overview

The intel system implements **fog of war** by tracking what each player knows about the game world. This ensures players only see information they should have access to, creating uncertainty and enabling strategic deception.

## Design Philosophy

**Core Principle**: Server stores complete truth, players receive filtered views.

- Server SQLite contains full authoritative game state
- Intel tables track each player's knowledge separately
- Player views are generated by filtering through intel tables
- Intel has timestamps (shows staleness)
- Different intel quality levels provide varying detail

## Visibility Mechanics

### System Visibility

Players can see systems through four visibility levels:

#### 1. Owned
**Trigger**: Player has a colony in the system
**Visibility**:
- Full system details
- All fleets in system (friendly and enemy)
- Complete colony information
- All jump lanes
- Real-time updates

**Intel Quality**: Perfect (current turn)

#### 2. Occupied
**Trigger**: Player has fleet(s) in the system
**Visibility**:
- System details
- Detected enemy fleets (visual range)
- Enemy colony presence (limited details)
- Jump lanes
- Real-time updates while occupied

**Intel Quality**: High (current turn)

#### 3. Scouted
**Trigger**: Player visited system previously, but no longer present
**Visibility**:
- System details (from last visit)
- Last known fleet positions (stale)
- Last known colony status (stale)
- Jump lanes
- Staleness indicator (turns since last visit)

**Intel Quality**: Degraded (stale by N turns)

#### 4. Adjacent
**Trigger**: System is one jump away from known system
**Visibility**:
- System name and coordinates
- Jump lane existence
- No fleet information
- No colony information

**Intel Quality**: Minimal (awareness only)

### Fleet Detection

Players can detect enemy fleets through three methods:

#### 1. Visual Detection
**Trigger**: Player fleet in same system as enemy fleet
**Visibility**:
- Fleet presence confirmed
- Ship count (approximate)
- Fleet owner (if identified)
- Current location

**Intel Quality**: Medium

**Staleness**: Updates each turn player remains in system, becomes stale when player leaves

#### 2. Sensor Scan
**Trigger**: Active scan operation (future feature)
**Visibility**:
- Fleet presence confirmed
- Exact ship count
- Ship types breakdown (Military vs Spacelift)
- Fleet owner
- Current location

**Intel Quality**: High

**Staleness**: Point-in-time snapshot

#### 3. Espionage
**Trigger**: Successful spy operation (foSpySystem)
**Visibility**:
- All fleets in system
- Exact composition
- Hull points and damage
- Fleet orders (if successful)

**Intel Quality**: Perfect

**Staleness**: Point-in-time snapshot, degrades rapidly

### Colony Intelligence

Players can learn about enemy colonies through:

#### 1. Spy Operation
**Trigger**: Successful foSpyPlanet order
**Visibility**:
- Population
- Industry
- Defenses
- Starbase level
- Construction queue (if successful)

**Intel Quality**: High to Perfect

**Staleness**: Point-in-time snapshot

#### 2. Capture
**Trigger**: Successfully invade and capture colony
**Visibility**:
- Complete colony details
- Historical intel from colony's previous owner

**Intel Quality**: Perfect

**Staleness**: None (now owned)

#### 3. Sensor Scan
**Trigger**: Active scan from fleet in system
**Visibility**:
- Partial colony details
- Approximate industry and defenses
- Starbase level

**Intel Quality**: Medium

**Staleness**: Point-in-time snapshot

## Database Schema

See [storage.md](./storage.md) for complete schema. Key tables:

### intel_systems
Tracks system visibility per player.

**Fields**:
- `house_id`: Who has this intel
- `system_id`: What system
- `last_scouted_turn`: When last updated
- `visibility_level`: owned/occupied/scouted/adjacent

### intel_fleets
Tracks detected enemy fleets per player.

**Fields**:
- `house_id`: Who detected
- `fleet_id`: Enemy fleet
- `detected_turn`: When last seen
- `detected_system_id`: Where it was
- `ship_count`: How many ships
- `ship_types`: Breakdown by type (JSON)
- `intel_quality`: visual/scan/spy

### intel_colonies
Tracks known enemy colony details per player.

**Fields**:
- `house_id`: Who has intel
- `colony_id`: Target colony
- `intel_turn`: When gathered
- `population`, `industry`, `defenses`, `starbase_level`: Colony stats
- `intel_source`: spy/capture/scan

## Intel Update Process

### Turn Resolution Intel Updates

After each turn resolution phase, the daemon updates intel tables:

```
1. Income Phase Complete
   → No intel updates

2. Command Phase Complete
   → Update fleet positions
   → Update system visibility based on movements
   → Visual detection of enemy fleets

3. Conflict Phase Complete
   → Update combat results visibility
   → Detect new fleets from combat
   → Update fleet intel (damaged ships)

4. Maintenance Phase Complete
   → Update colony intel from spy operations
   → Process scan results
   → Age stale intel
```

### System Visibility Updates

**For each player, each turn:**

1. **Mark owned systems**: Systems with player's colonies → 'owned'
2. **Mark occupied systems**: Systems with player's fleets → 'occupied'
3. **Update scouted systems**: Previously occupied systems → 'scouted'
4. **Mark adjacent systems**: One jump from known systems → 'adjacent'
5. **Prune**: Remove intel for systems no longer relevant (optional)

**SQL Pattern:**
```sql
-- Owned systems
INSERT OR REPLACE INTO intel_systems (game_id, house_id, system_id, last_scouted_turn, visibility_level)
SELECT ?game_id, ?house_id, c.system_id, ?current_turn, 'owned'
FROM colonies c
WHERE c.owner_house_id = ?house_id;

-- Occupied systems
INSERT OR REPLACE INTO intel_systems (game_id, house_id, system_id, last_scouted_turn, visibility_level)
SELECT ?game_id, ?house_id, f.location_system_id, ?current_turn, 'occupied'
FROM fleets f
WHERE f.owner_house_id = ?house_id;
```

### Fleet Detection Updates

**For each player, each turn:**

1. **Visual detection**: Detect enemy fleets in same systems as player's fleets
2. **Update ship counts**: Count ships in detected fleets
3. **Update positions**: Record where fleet was seen
4. **Mark stale**: Don't delete old intel, just mark turn detected

**SQL Pattern:**
```sql
INSERT OR REPLACE INTO intel_fleets
  (game_id, house_id, fleet_id, detected_turn, detected_system_id, ship_count, ship_types, intel_quality)
SELECT
  ?game_id,
  ?house_id,
  enemy_f.id,
  ?current_turn,
  enemy_f.location_system_id,
  (SELECT COUNT(*) FROM ships WHERE fleet_id = enemy_f.id),
  (SELECT json_group_object(ship_type, COUNT(*)) FROM ships WHERE fleet_id = enemy_f.id GROUP BY ship_type),
  'visual'
FROM fleets player_f
JOIN fleets enemy_f ON player_f.location_system_id = enemy_f.location_system_id
WHERE player_f.owner_house_id = ?house_id
  AND enemy_f.owner_house_id != ?house_id;
```

### Colony Intel Updates

**From spy operations:**

When `foSpyPlanet` succeeds:
```sql
INSERT OR REPLACE INTO intel_colonies
  (game_id, house_id, colony_id, intel_turn, population, industry, defenses, starbase_level, intel_source)
VALUES (?game_id, ?spy_house, ?target_colony, ?current_turn, ?, ?, ?, ?, 'spy');
```

## Player View Generation

### Filtering Game State

When generating a player's view (for client or Nostr delta):

**Algorithm:**
```
1. Load player's own assets (full detail)
   - Houses, colonies, fleets, ships

2. Load visible systems
   - Query intel_systems for house_id
   - Include system details based on visibility_level

3. Load detected enemy fleets
   - Query intel_fleets for house_id
   - Include last known position and composition
   - Mark staleness (current_turn - detected_turn)

4. Load known enemy colonies
   - Query intel_colonies for house_id
   - Include stats from intel_turn
   - Mark staleness

5. Load public information
   - Diplomacy relations
   - Prestige scores
   - Turn summaries

6. Filter turn log events
   - Include events where visible_to_house_id = house_id
   - Include events where visible_to_house_id IS NULL (public)
```

### Example View Generation

**Player Alpha in turn 10:**

**Sees:**
- Own 3 colonies (full detail, current)
- Own 5 fleets (full detail, current)
- 8 systems: 3 owned, 2 occupied, 2 scouted, 1 adjacent
- Enemy fleet in System B (detected turn 10, visual, 7 ships)
- Enemy fleet in System D (detected turn 7, visual, 5 ships) - **3 turns stale**
- Enemy colony in System C (spied turn 8, 10 industry) - **2 turns stale**

**Does NOT see:**
- Enemy fleets in systems never visited
- Enemy colonies in unscouted systems
- Exact enemy fleet movements outside visibility
- Enemy orders or plans

## Staleness and Uncertainty

### Displaying Stale Intel

**UI Guidelines:**
- Show turn number of last update
- Visual indicator for staleness (color, icon)
- Warning if intel > 3 turns old
- "Last seen turn X" labels

**Example:**
```
System Delta
  Last scouted: Turn 7 (3 turns ago)
  Enemy fleet: 5 Military ships (possibly moved)
  Enemy colony: ~8 industry (may have grown)
```

### Intel Decay

**Optional feature**: Degrade intel quality over time

**Proposed Rules:**
- Visual intel: Valid for 3 turns, then deleted
- Scan intel: Valid for 5 turns, then deleted
- Spy intel: Valid for 5 turns, then deleted
- System scouted: Never deleted (permanent map knowledge)

**Implementation:**
```sql
-- Clean up stale fleet intel (>5 turns old)
DELETE FROM intel_fleets
WHERE game_id = ?game_id
  AND (?current_turn - detected_turn) > 5;
```

## Strategic Implications

### Fog of War Encourages

**Reconnaissance**:
- Patrol borders with scout fleets
- Sacrifice ships to gain intel
- Maintain system visibility

**Deception**:
- Hide fleets in unscouted systems
- Feint attacks to mislead
- False intel from spies (future)

**Spy Operations**:
- Invest in espionage for accurate intel
- Counter-intelligence to block enemy spies
- Information warfare

**Tactical Surprise**:
- Attack from unexpected directions
- Ambush fleets with hidden forces
- Sneak colonization of border systems

## Nostr Integration

### Encrypted Fog of War

**Key Design**: Each player receives different encrypted game state.

**Moderator generates per-player deltas:**
```
For each house:
  1. Query intel tables for house_id
  2. Generate filtered GameState
  3. Serialize to JSON
  4. Encrypt to house's Nostr pubkey (NIP-44)
  5. Publish EventKindStateDelta
```

**Result**: Players literally cannot decrypt other players' views.

**Benefit**: Fog of war enforced by cryptography, not just access control.

### Localhost Mode

**Filesystem separation:**
```
game-123/
  houses/
    house_alpha/
      turn_results/turn_10.json  (Alice's view)
    house_beta/
      turn_results/turn_10.json  (Bob's view)
```

**Security**: Honor system (players don't peek at other files).

**Use case**: Trusted hotseat multiplayer, development testing.

## Future Enhancements

### Advanced Intel Mechanics

**Intel Sharing**:
- Allies share scouting intel
- Trade intel with other players
- Diplomacy actions: "Share Intel on House Red"

**Counter-Intelligence**:
- Detect enemy spies
- Feed false intel to spies
- Encryption research (fog of war density)

**Intel Quality Levels**:
- 0%: No intel (never visited)
- 25%: Minimal (adjacent system)
- 50%: Stale (visited 5+ turns ago)
- 75%: Recent (visited 1-2 turns ago)
- 100%: Perfect (current, owned/occupied)

**Sensor Technology**:
- Long-range sensors (detect fleets 2 jumps away)
- Deep scans (reveal colony details without spy)
- Stealth tech (avoid detection)

### Partial Information Combat

**Combat fog of war**:
- Don't reveal exact enemy fleet composition until combat
- After battle: update intel based on combat results
- Surprise attacks if enemy unaware of your fleet

**Example**:
```
Turn 10: Player Alpha sees "enemy fleet in System B" (visual, 7 ships)
Turn 11: Player Alpha attacks System B
Combat Resolution: Enemy fleet revealed as 5 Military + 2 Spacelift
After combat: Intel updated with exact composition
```

## Testing Intel System

### Test Scenarios

**Scenario 1: Basic Visibility**
- Player A in System 1 (owned)
- Player B in System 2 (adjacent)
- Player A should see System 2 as 'adjacent', no fleet details

**Scenario 2: Fleet Detection**
- Player A fleet moves to System 5
- Player B fleet already in System 5
- Both players should detect each other (visual intel)

**Scenario 3: Staleness**
- Turn 1: Player A scouts System 10 (detects enemy fleet)
- Turn 5: Player A no longer in System 10
- Player A should still see fleet at System 10, marked "4 turns stale"

**Scenario 4: Spy Operation**
- Turn 8: Player A successfully spies on Player B's colony
- Player A should see exact colony stats (intel_turn=8)
- Turn 12: Intel marked "4 turns stale"

### Debug Tools

**SQL Queries for Testing**:

```sql
-- What does Player A see?
SELECT s.name, i.visibility_level, i.last_scouted_turn
FROM intel_systems i
JOIN systems s ON i.system_id = s.id
WHERE i.house_id = 'house-alpha';

-- What fleets has Player A detected?
SELECT f.id, i.detected_system_id, i.ship_count,
       (?current_turn - i.detected_turn) as staleness
FROM intel_fleets i
JOIN fleets f ON i.fleet_id = f.id
WHERE i.house_id = 'house-alpha';
```

**Moderator Command**:
```bash
moderator intel <game-id> --house=Alpha --show-staleness
# Display Player Alpha's complete intel picture
```

## Architecture Decision: Intel Reports vs Raw Data (Jan 2026)

### Problem

The original design had the engine generating **human-readable narrative reports** (e.g., "Your scout detected 5 enemy ships at Alpha Centauri") and storing them in `IntelDatabase.scoutEncounters`, `.combatReports`, etc. This created several issues:

1. **Bandwidth waste**: Sending narrative reports over Nostr was expensive
2. **Presentation coupling**: Engine contained UI-layer logic (report formatting)
3. **Dead code**: ~1,880 lines of report generation code that was never used
4. **Duplication**: Reports duplicated information already in `GameEvent` stream

### Solution

**Engine responsibility:**
- Track fog-of-war observations (what each house has seen, when)
- Store structured observation data in `IntelDatabase`:
  - `ColonyObservation` - Enemy colony data from last scout
  - `FleetObservation` - Enemy fleet data from last detection
  - `SystemObservation` - System surveillance data
  - `StarbaseObservation` - Economic intel from HackStarbase
- Generate `PlayerState` (filtered game state view per house)
- Emit `GameEvent` stream (structured events: who, what, where, when)

**Client responsibility:**
- Receive `PlayerState` deltas (KDL format)
- Receive filtered `GameEvent` stream
- Generate human-readable reports from:
  - PlayerState changes (diff detection)
  - GameEvent narrative (e.g., "House Atreides declared war on House Harkonnen")
  - Localization, formatting, verbosity preferences

### Data Flow Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          SERVER (Daemon)                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐    ┌──────────────────┐    ┌─────────────────────┐    │
│  │   Game Engine   │───▶│   SQLite Store   │───▶│  Fog-of-War Filter  │    │
│  │  (Full State)   │    │  (Single Truth)  │    │ (Per-House Views)   │    │
│  └─────────────────┘    └──────────────────┘    └──────────┬──────────┘    │
│                                                            │               │
│                         ┌──────────────────────────────────┴───┐           │
│                         ▼                                      ▼           │
│              ┌────────────────────┐              ┌────────────────────┐    │
│              │   Localhost Mode   │              │    Nostr Mode      │    │
│              │   (File System)    │              │   (Encrypted)      │    │
│              └─────────┬──────────┘              └─────────┬──────────┘    │
└────────────────────────┼──────────────────────────────────┼────────────────┘
                         │                                  │
                         ▼                                  ▼
              ┌────────────────────┐              ┌────────────────────┐
              │  houses/<house>/   │              │  NIP-44 Encrypted  │
              │  turn_results/     │              │  Event (30002)     │
              │  turn_N.kdl        │              │  Per-Player Delta  │
              └─────────┬──────────┘              └─────────┬──────────┘
                         │                                  │
                         ▼                                  ▼
              ┌────────────────────────────────────────────────────────┐
              │                     CLIENT                             │
              │  Receives: PlayerState (KDL)                          │
              │  - Full entity data for owned assets                  │
              │  - Limited intel for enemy assets                     │
              │  - Visibility levels for systems                      │
              └────────────────────────────────────────────────────────┘
```

**PlayerState Structure:**
```nim
PlayerState = object
  viewingHouse: HouseId
  turn: int32
  
  # === Owned Assets (Full Entity Data) ===
  ownColonies: seq[Colony]        # Complete colony objects
  ownFleets: seq[Fleet]           # Complete fleet objects
  ownShips: seq[Ship]             # Complete ship objects
  ownGroundUnits: seq[GroundUnit] # Complete ground unit objects
  
  # === Visible Systems (Fog of War) ===
  visibleSystems: Table[SystemId, VisibleSystem]  # Visibility level per system
  
  # === Enemy Assets (Limited Intel) ===
  visibleColonies: seq[VisibleColony]  # Partial data based on intel
  visibleFleets: seq[VisibleFleet]     # Detection-based, stale data possible
  
  # === Public Information ===
  housePrestige: Table[HouseId, int32]
  houseColonyCounts: Table[HouseId, int32]
  diplomaticRelations: Table[(HouseId, HouseId), DiplomaticState]
  eliminatedHouses: seq[HouseId]
  actProgression: ActProgressionState
```

**Bandwidth Optimization:**
- **Turn 1**: Full PlayerState sent (complete snapshot)
- **Turn 2+**: Delta format sent (only changes)
```kdl
turn 42
delta {
  fleet-moved id="fleet-1" from="sys-A" to="sys-B"
  ship-damaged id="ship-5" hp=8
  colony-updated id="col-3" industry=12
}
```

### Types Consolidated into player_state.nim

**Fog-of-war observation types** (engine stores what was observed):
- `IntelQuality` {Visual, Scan, Perfect} - How intel was gathered
- `ColonyObservation` - Colony intel (population, infrastructure, etc.)
- `OrbitalObservation` - Orbital asset intel (starbases, shipyards)
- `SystemObservation` - System surveillance (detected fleets)
- `FleetObservation` / `ShipObservation` - Fleet/ship details
- `StarbaseObservation` - Economic intel (treasury, tax rate, research)
- `IntelDatabase` - Per-house storage (trimmed to 6 fields)

**Client-facing view types** (generated per turn, sent to client):
- `VisibilityLevel` {None, Adjacent, Scouted, Occupied, Owned}
- `VisibleSystem` - System visibility status
- `VisibleColony` - Enemy colony with limited intel
- `VisibleFleet` - Enemy fleet with limited intel
- `PlayerState` - Complete filtered state for a house

### Removed Dead Code

**Deleted files** (~1,880 lines):
- `intel/combat_intel.nim` - Generated combat narrative reports (never read)
- `intel/blockade_intel.nim` - Generated blockade reports (never read)
- `intel/scout_intel.nim` - Generated scout encounter reports (never read)
- `intel/espionage_intel.nim` - Generated espionage reports (never read)
- `intel/diplomatic_intel.nim` - Redundant with GameEvents
- `intel/starbase_surveillance.nim` - Wrote to unused field
- `intel/event_processor/` - Event→Report conversion (never called)

**Removed types** (~400 lines):
- `ScoutEncounterReport`, `CombatEncounterReport`, `BlockadeReport`
- `StarbaseSurveillanceReport`, `EspionageActivityReport`
- `FleetMovementHistory`, `ConstructionActivityReport`
- `PopulationTransferStatusReport`

**Total reduction**: ~2,280 lines

### Benefits

1. **Bandwidth efficient**: Transport sends delta format (KDL) with minimal data
2. **Clear separation**: Engine = data, Client = presentation
3. **Flexibility**: Different clients can format reports differently
4. **Maintainability**: No duplicate logic between GameEvents and intel reports
5. **Simpler fog-of-war**: Single source of truth (IntelDatabase observations)

### Implementation Notes

- `PlayerState` is regenerated each turn by filtering current `GameState` through `IntelDatabase`
- Staleness is tracked via `gatheredTurn` field on observations
- Transport layer (Nostr) delivers encrypted `PlayerState` + `GameEvent` stream per player
- Client diffs PlayerState to detect changes and generate narrative

## Related Documentation

- [Storage Schema](./storage.md) - Intel table definitions
- [Data Flow](./dataflow.md) - When intel is updated
- [Daemon Design](./daemon.md) - Intel update process
- [Transport Layer](./transport.md) - How filtered views are delivered (KDL format)
