## Persistence Reader: Load GameState from DB

import std/[tables, options, json, strutils, jsonutils, os]
import db_connector/db_sqlite
import ../../common/logger
import ../../engine/types/[game_state, core, house, starmap, colony, fleet, ship, command, tech, production, diplomacy, espionage, player_state]
import ../../engine/state/engine
import ./player_state_snapshot

# Replay protection

type ReplayDirection* {.pure.} = enum
  Inbound = 0
  Outbound = 1

proc getHousePubkey*(dbPath: string, gameId: string, houseId: HouseId): Option[string] =
  ## Get a house's Nostr pubkey from database
  ## Returns None if house not found or pubkey not set
  let db = open(dbPath, "", "", "")
  defer: db.close()
  
  let row = db.getRow(
    sql"SELECT nostr_pubkey FROM houses WHERE game_id = ? AND id = ?",
    gameId,
    $houseId.uint32
  )
  
  if row[0] != "":
    return some(row[0])
  else:
    return none(string)

proc getHouseByInviteCode*(dbPath: string, gameId: string,
  inviteCode: string): Option[HouseId] =
  ## Get house id by invite code
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"SELECT id FROM houses WHERE game_id = ? AND invite_code = ?",
    gameId,
    inviteCode
  )

  if row[0] == "":
    return none(HouseId)

  try:
    return some(HouseId(parseInt(row[0]).uint32))
  except CatchableError:
    logError("Persistence", "Failed to parse house id for invite code")
    return none(HouseId)

proc getHouseInviteCode*(dbPath: string, gameId: string,
  houseId: HouseId): Option[string] =
  ## Get invite code for a house
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"SELECT invite_code FROM houses WHERE game_id = ? AND id = ?",
    gameId,
    $houseId.uint32
  )

  if row[0] != "":
    return some(row[0])
  else:
    return none(string)

proc isInviteCodeClaimed*(dbPath: string, gameId: string,
  inviteCode: string): bool =
  ## Returns true if invite code already assigned a pubkey
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"""
    SELECT nostr_pubkey
    FROM houses
    WHERE game_id = ? AND invite_code = ?
  """,
    gameId,
    inviteCode
  )

  if row[0] == "":
    return false
  else:
    return true

proc isInviteCodeAssigned*(dbPath: string, gameId: string,
  inviteCode: string): bool =
  ## Returns true if invite code is already assigned to a house
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"""
    SELECT id
    FROM houses
    WHERE game_id = ? AND invite_code = ?
  """,
    gameId,
    inviteCode
  )

  if row[0] == "":
    return false
  else:
    return true

proc loadPlayerStateSnapshot*(
  dbPath: string,
  gameId: string,
  houseId: HouseId,
  turn: int32
): Option[PlayerStateSnapshot] =
  ## Load a per-house PlayerState snapshot from the database
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"""
    SELECT state_json
    FROM player_state_snapshots
    WHERE game_id = ? AND house_id = ? AND turn = ?
  """,
    gameId,
    $houseId.uint32,
    $turn
  )

  if row[0] == "":
    return none(PlayerStateSnapshot)

  try:
    return some(snapshotFromJson(row[0]))
  except CatchableError:
    logError("Persistence", "Failed to parse player state snapshot: ", getCurrentExceptionMsg())
    return none(PlayerStateSnapshot)

proc hasProcessedEvent*(dbPath: string, gameId: string, kind: int,
  eventId: string, direction: ReplayDirection): bool =
  ## Returns true if an event id was already processed
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"""
    SELECT event_id
    FROM nostr_event_log
    WHERE game_id = ? AND kind = ? AND event_id = ? AND direction = ?
  """,
    gameId,
    $kind,
    eventId,
    $(direction.ord)
  )

  return row[0] != ""

proc loadHouses(db: DbConn, state: GameState) =
  let rows = db.getAllRows(sql"SELECT state_json FROM houses")
  for row in rows:
    try:
      let house = parseJson(row[0]).jsonTo(House)
      state.addHouse(house.id, house)
    except:
      logError("Persistence", "Failed to load house: ", getCurrentExceptionMsg())

proc loadSystems(db: DbConn, state: GameState) =
  let rows = db.getAllRows(sql"SELECT id, name, hex_q, hex_r, ring, planet_class, resource_rating FROM systems")
  for row in rows:
    try:
      let systemId = SystemId(parseInt(row[0]).uint32) # Wait, IDs are usually distinct uint32, but stored as string?
      # writer.nim uses `$system.id`. If ID is 1, string is "1".
      # parseInt("1") -> 1.
      # If ID is UUID string?
      # src/engine/types/core.nim: SystemId* = distinct uint32.
      # So it IS integer based.
      # But `generateGameId` returns UUID string.
      # `generateHouseId` returns uint32.
      # System IDs generated by `generateStarMap` are integers (counters).
      # So `parseInt` is correct.
      
      let system = System(
        id: systemId,
        name: row[1],
        coords: Hex(q: int32(parseInt(row[2])), r: int32(parseInt(row[3]))),
        ring: uint32(parseInt(row[4])),
        planetClass: PlanetClass(parseInt(row[5])),
        resourceRating: ResourceRating(parseInt(row[6]))
      )
      state.addSystem(system.id, system)
    except:
      logError("Persistence", "Failed to load system: ", getCurrentExceptionMsg())

proc loadLanes(db: DbConn, state: GameState) =
  let rows = db.getAllRows(sql"SELECT from_system_id, to_system_id, lane_type FROM lanes")
  # We need to populate state.starMap.lanes
  # starMap.lanes is JumpLanes object.
  # We should use a helper or manual population.
  # JumpLanes has `data`, `neighbors`, `connectionInfo`.
  # Engine doesn't seem to have `addLane`?
  # state/engine.nim doesn't have `addLane`.
  # We might need to manually construct `state.starMap.lanes`.
  # Or use `starmap` module helpers?
  # For now, I'll populate `data` and then I should probably rebuild indices?
  # `starmap.nim` defines `JumpLanes`.
  
  state.starMap.lanes = JumpLanes(
    data: @[],
    neighbors: initTable[SystemId, seq[SystemId]](),
    connectionInfo: initTable[(SystemId, SystemId), LaneClass]()
  )
  
  for row in rows:
    try:
      let source = SystemId(parseInt(row[0]).uint32)
      let dest = SystemId(parseInt(row[1]).uint32)
      let laneTypeStr = row[2]
      let laneType = parseEnum[LaneClass](laneTypeStr)
      
      let lane = JumpLane(source: source, destination: dest, laneType: laneType)
      state.starMap.lanes.data.add(lane)
      
      # Rebuild neighbors
      if not state.starMap.lanes.neighbors.hasKey(source):
        state.starMap.lanes.neighbors[source] = @[]
      state.starMap.lanes.neighbors[source].add(dest)
      
      # Rebuild connectionInfo
      state.starMap.lanes.connectionInfo[(source, dest)] = laneType
    except:
      logError("Persistence", "Failed to load lane: ", getCurrentExceptionMsg())

proc loadColonies(db: DbConn, state: GameState) =
  let rows = db.getAllRows(sql"SELECT state_json FROM colonies")
  for row in rows:
    try:
      let colony = parseJson(row[0]).jsonTo(Colony)
      state.addColony(colony.id, colony)
      
      # Also update indices? addColony handles entities.
      # But `state.colonies` has `bySystem` and `byOwner`.
      # `addColony` (from state/engine.nim) only updates `entities`.
      # I check `state/engine.nim`: `state.colonies.entities.addEntity(id, colony)`.
      # It does NOT update `bySystem` / `byOwner`.
      # I must update them manually.
      
      state.colonies.bySystem[colony.systemId] = colony.id
      if not state.colonies.byOwner.hasKey(colony.owner):
        state.colonies.byOwner[colony.owner] = @[]
      state.colonies.byOwner[colony.owner].add(colony.id)
    except:
      logError("Persistence", "Failed to load colony: ", getCurrentExceptionMsg())

proc loadFleets(db: DbConn, state: GameState) =
  let rows = db.getAllRows(sql"SELECT state_json FROM fleets")
  for row in rows:
    try:
      let fleet = parseJson(row[0]).jsonTo(Fleet)
      state.addFleet(fleet.id, fleet)
      
      # Update indices
      if not state.fleets.bySystem.hasKey(fleet.location):
        state.fleets.bySystem[fleet.location] = @[]
      state.fleets.bySystem[fleet.location].add(fleet.id)
      
      if not state.fleets.byOwner.hasKey(fleet.houseId):
        state.fleets.byOwner[fleet.houseId] = @[]
      state.fleets.byOwner[fleet.houseId].add(fleet.id)
    except:
      logError("Persistence", "Failed to load fleet: ", getCurrentExceptionMsg())

proc loadShips(db: DbConn, state: GameState) =
  let rows = db.getAllRows(sql"SELECT state_json FROM ships")
  for row in rows:
    try:
      let ship = parseJson(row[0]).jsonTo(Ship)
      state.addShip(ship.id, ship)
      
      # Update indices
      if not state.ships.byHouse.hasKey(ship.houseId):
        state.ships.byHouse[ship.houseId] = @[]
      state.ships.byHouse[ship.houseId].add(ship.id)
      
      if ship.fleetId.uint32 != 0: # Check if assigned to fleet
        if not state.ships.byFleet.hasKey(ship.fleetId):
          state.ships.byFleet[ship.fleetId] = @[]
        state.ships.byFleet[ship.fleetId].add(ship.id)
        
      # byCarrier index?
      # If ship is fighter/assigned? 
      # `assignedToCarrier` option.
      # Not critical for now, but good to have.
    except:
      logError("Persistence", "Failed to load ship: ", getCurrentExceptionMsg())

proc loadGameState*(dbPath: string): GameState =
  ## Load lightweight GameState (metadata only) from per-game DB
  ## Used for daemon discovery
  let db = open(dbPath, "", "", "")
  defer: db.close()

  # Load metadata
  let metadata = db.getRow(sql"SELECT * FROM games LIMIT 1")
  result = GameState(
    gameId: metadata[0],
    gameName: metadata[1],
    gameDescription: metadata[2],
    turn: int32(parseInt(metadata[3])),
    phase: GamePhase.Conflict,
    dbPath: dbPath
  )

proc loadGameDeadline*(dbPath: string): Option[int64] =
  ## Load turn deadline timestamp (unix seconds) for a game
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(sql"SELECT turn_deadline FROM games LIMIT 1")
  if row[0] == "" or row[0] == "NULL":
    return none(int64)

  try:
    return some(parseInt(row[0]).int64)
  except CatchableError:
    logError("Persistence", "Failed to parse turn_deadline")
    none(int64)

proc loadGamePhase*(dbPath: string): string =
  ## Load game phase string
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(sql"SELECT phase FROM games LIMIT 1")
  if row[0].len == 0:
    return ""
  row[0]

proc loadDiplomacy(db: DbConn, state: GameState) =
  ## Load diplomatic relations from diplomacy table
  let rows = db.getAllRows(sql"""
    SELECT house_a_id, house_b_id, relation, turn_established
    FROM diplomacy
  """)
  for row in rows:
    try:
      let houseA = HouseId(parseInt(row[0]).uint32)
      let houseB = HouseId(parseInt(row[1]).uint32)
      let relationStr = row[2]
      let sinceTurn = parseInt(row[3]).int32

      # Parse relation string to DiplomaticState
      let dipState = case relationStr
        of "Neutral": DiplomaticState.Neutral
        of "Hostile": DiplomaticState.Hostile
        of "Enemy": DiplomaticState.Enemy
        else: DiplomaticState.Neutral

      let relation = DiplomaticRelation(
        sourceHouse: houseA,
        targetHouse: houseB,
        state: dipState,
        sinceTurn: sinceTurn
      )
      state.diplomaticRelation[(houseA, houseB)] = relation
    except:
      logError("Persistence", "Failed to load diplomacy: ",
        getCurrentExceptionMsg())

proc loadIntel(db: DbConn, state: GameState) =
  ## Load intelligence databases from intel_* tables
  ## Note: This is a basic implementation that loads system intel only
  ## Fleet and colony intel can be added when needed
  let rows = db.getAllRows(sql"""
    SELECT house_id, system_id, last_scouted_turn, visibility_level
    FROM intel_systems
  """)
  for row in rows:
    try:
      let houseId = HouseId(parseInt(row[0]).uint32)
      let systemId = SystemId(parseInt(row[1]).uint32)
      let gatheredTurn = parseInt(row[2]).int32
      discard row[3]  # visibility_level not used in SystemObservation

      # Initialize IntelDatabase for house if not exists
      if not state.intel.hasKey(houseId):
        state.intel[houseId] = IntelDatabase(
          houseId: houseId,
          colonyObservations: initTable[ColonyId, ColonyObservation](),
          orbitalObservations: initTable[ColonyId, OrbitalObservation](),
          systemObservations: initTable[SystemId, SystemObservation](),
          starbaseObservations: initTable[KastraId, StarbaseObservation](),
          fleetObservations: initTable[FleetId, FleetObservation](),
          shipObservations: initTable[ShipId, ShipObservation]()
        )

      # Create basic system observation (quality can be inferred from db later)
      let sysObs = SystemObservation(
        systemId: systemId,
        gatheredTurn: gatheredTurn,
        quality: IntelQuality.Visual,  # Default quality
        detectedFleetIds: @[]
      )
      state.intel[houseId].systemObservations[systemId] = sysObs
    except:
      logError("Persistence", "Failed to load intel: ",
        getCurrentExceptionMsg())

proc loadOrders*(dbPath: string, turn: int): Table[HouseId, CommandPacket] =
  ## Load all command packets for a specific turn from the database
  let db = open(dbPath, "", "", "")
  defer: db.close()
  
  result = initTable[HouseId, CommandPacket]()
  
  # Group commands by house_id
  let rows = db.getAllRows(sql"""
    SELECT house_id, fleet_id, colony_id, command_type, target_system_id, target_fleet_id, params
    FROM commands
    WHERE turn = ? AND processed = 0
  """, $turn)
  
  for row in rows:
    let houseId = HouseId(parseInt(row[0]).uint32)
    if not result.hasKey(houseId):
      result[houseId] = CommandPacket(
        houseId: houseId,
        turn: turn.int32,
        fleetCommands: @[],
        buildCommands: @[],
        # ... init other fields
      )
    
    let fleetIdStr = row[1]
    let colonyIdStr = row[2]
    discard colonyIdStr
    let cmdType = row[3]
    let params = parseJson(row[6])
    
    if fleetIdStr != "":
      # Fleet command
      var cmd = FleetCommand(
        fleetId: FleetId(parseInt(fleetIdStr).uint32),
        commandType: parseEnum[FleetCommandType](cmdType)
      )
      if row[4] != "": cmd.targetSystem = some(SystemId(parseInt(row[4]).uint32))
      if row[5] != "": cmd.targetFleet = some(FleetId(parseInt(row[5]).uint32))
      if params.hasKey("roe") and params["roe"].kind != JNull:
        cmd.roe = some(params["roe"].getInt().int32)
      if params.hasKey("priority"):
        cmd.priority = params["priority"].getInt().int32
      result[houseId].fleetCommands.add(cmd)
    elif cmdType == "Build":
      # Build command
      let cmd = params.jsonTo(BuildCommand)
      result[houseId].buildCommands.add(cmd)
    elif cmdType == "Research":
      # Research allocation (manual deserialization for enum-keyed table)
      var alloc = ResearchAllocation(
        economic: params["economic"].getInt().int32,
        science: params["science"].getInt().int32,
        technology: initTable[TechField, int32]()
      )
      if params.hasKey("technology") and params["technology"].kind == JObject:
        for fieldStr, pointsNode in params["technology"].pairs:
          let field = parseEnum[TechField](fieldStr)
          alloc.technology[field] = pointsNode.getInt().int32
      result[houseId].researchAllocation = alloc
    elif cmdType == "EspionageBudget":
      # Espionage budget investment
      result[houseId].ebpInvestment = params["ebpInvestment"].getInt().int32
      result[houseId].cipInvestment = params["cipInvestment"].getInt().int32
    elif cmdType == "EspionageAction":
      # Espionage action
      let action = params.jsonTo(EspionageAttempt)
      result[houseId].espionageActions.add(action)
    elif cmdType == "Diplomatic":
      # Diplomatic command
      let cmd = params.jsonTo(DiplomaticCommand)
      result[houseId].diplomaticCommand.add(cmd)

  logInfo("Persistence", "Loaded ", $result.len, " command packets for turn ", $turn)

proc loadFullState*(dbPath: string): GameState =
  ## Load full GameState from per-game DB
  let db = open(dbPath, "", "", "")
  defer: db.close()

  # Load metadata
  let metadata = db.getRow(sql"SELECT * FROM games LIMIT 1")
  result = GameState(
    gameId: metadata[0],
    gameName: metadata[1],
    gameDescription: metadata[2],
    turn: int32(parseInt(metadata[3])),
    phase: GamePhase.Conflict, 
    dbPath: dbPath,
    dataDir: dbPath.parentDir.parentDir.parentDir # ../../../data
  )
  
  # Init collections
  result.houses.entities.index = initTable[HouseId, int]()
  result.systems.entities.index = initTable[SystemId, int]()
  result.colonies.entities.index = initTable[ColonyId, int]()
  result.fleets.entities.index = initTable[FleetId, int]()
  result.ships.entities.index = initTable[ShipId, int]()
  
  result.colonies.bySystem = initTable[SystemId, ColonyId]()
  result.colonies.byOwner = initTable[HouseId, seq[ColonyId]]()
  result.fleets.bySystem = initTable[SystemId, seq[FleetId]]()
  result.fleets.byOwner = initTable[HouseId, seq[FleetId]]()
  result.ships.byHouse = initTable[HouseId, seq[ShipId]]()
  result.ships.byFleet = initTable[FleetId, seq[ShipId]]()
  result.ships.byCarrier = initTable[ShipId, seq[ShipId]]()
  
  # Load entities
  try:
    loadSystems(db, result)
    loadLanes(db, result)
    loadHouses(db, result)
    loadColonies(db, result)
    loadFleets(db, result)
    loadShips(db, result)
    loadDiplomacy(db, result)
    loadIntel(db, result)
    # Note: Ground units are loaded as part of colony state_json
    logInfo("Persistence", "Loaded full state", "turn=", $result.turn)
  except:
    logError("Persistence", "Failed to load full state: ", getCurrentExceptionMsg())
    raise

proc countExpectedPlayers*(dbPath: string, gameId: string): int =
  ## Count houses with assigned Nostr pubkeys (human players)
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"SELECT COUNT(*) FROM houses WHERE game_id = ? AND nostr_pubkey IS NOT NULL",
    gameId
  )
  result = parseInt(row[0])

proc countPlayersSubmitted*(dbPath: string, gameId: string, turn: int32): int =
  ## Count distinct houses that have submitted commands for a turn
  ## Returns number of houses with at least one unprocessed command
  let db = open(dbPath, "", "", "")
  defer: db.close()

  let row = db.getRow(
    sql"""
    SELECT COUNT(DISTINCT house_id)
    FROM commands
    WHERE game_id = ? AND turn = ? AND processed = 0
    """,
    gameId,
    $turn
  )
  result = parseInt(row[0])

