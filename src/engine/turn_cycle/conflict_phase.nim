## Conflict Phase Resolution - Phase 1 of Canonical Turn Cycle
##
## Resolves all combat and espionage operations for arrived fleets.
## Orders stored in Command Phase execute when fleets arrive at targets.
##
## **Canonical Execution Order:**
##
## 1. Space Combat (simultaneous resolution)
##   1a. Raider Detection
##   1b. Combat Resolution
## 2. Orbital Combat (simultaneous resolution)
##   2a. Raider Detection
##   2b. Combat Resolution
## 3. Blockade Resolution
## 4. Planetary Combat
## 5. Colonization
## 6. Espionage Operations
##   6a. Fleet-Based Espionage (includes Spy Scout Detection)
##   6b. Space Guild Espionage
##   6c. Starbase Surveillance

import std/[options, random, sequtils, strformat, tables]
import ../types/core
import ../../common/logger as common_logger
import ../types/game_state
import
  ../types/[
    diplomacy as dip_types,
    espionage as esp_types,
    intelligence as intel_types,
    fleet,
    research as res_types_research,
    resolution as res_types,
    simultaneous as simultaneous_types,
  ]
# import ../systems/combat/simultaneous_blockade  # REMOVED: Legacy squadron-based system
import ../systems/combat/orchestrator # Theater progression (Space → Orbital → Planetary)
import ../systems/espionage/resolution as espionage_resolution
import
  ../systems/intelligence/
    [espionage_intel, generator, spy_resolution, starbase_surveillance]
import ../systems/prestige/application as prestige_app
import ../systems/prestige/types as prestige_types
import ../systems/colony/simultaneous

proc resolveConflictPhase*(
    state: var GameState,
    orders: Table[HouseId, OrderPacket],
    combatReports: var seq[res_types.CombatReport],
    events: var seq[res_types.GameEvent],
    rng: var Rand,
) =
  ## Phase 1: Resolve all combat and infrastructure damage
  ## This happens FIRST so damaged facilities affect production
  logInfo(LogCategory.lcOrders, &"=== Conflict Phase === (turn={state.turn})")
  logInfo(LogCategory.lcOrders, &"Using RNG for combat resolution (seed={state.turn})")

  # Start with current turn orders (will merge state.fleetCommands below)
  var effectiveOrders = orders

  # ===================================================================
  # STEP 0: MERGE ACTIVE FLEET ORDERS (from state.fleetCommands)
  # ===================================================================
  # Per canonical turn cycle: Step 0 merges orders for execution
  # Universal lifecycle: Orders stored in Command Phase (or generated by standing
  # orders in Maintenance Phase) are now merged for Conflict Phase execution.
  # Only merge orders that execute in Conflict Phase (skip Move, Patrol, Salvage).
  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEP 0] Merging fleet orders for Conflict Phase execution " &
      &"({state.fleetCommands.len} total orders in state)...",
  )

  var mergedFleetOrderCount = 0
  for fleetId, fleetCommand in state.fleetCommands:
    # Only merge orders that execute in Conflict Phase
    # Skip orders that execute in other phases:
    # - Movement orders (Move, Patrol, etc.): Execute in Maintenance Phase
    # - Salvage: Executes in Income Phase
    if isMovementOrder(fleetCommand.commandType) or
        fleetCommand.commandType == FleetCommandType.Salvage:
      continue

    # Find fleet owner
    if fleetId notin state.fleets:
      logDebug(LogCategory.lcOrders, &"  [SKIP] Fleet {fleetId} no longer exists")
      continue

    let fleetOwner = state.fleets[fleetId].owner

    # Ensure owner has order packet
    if fleetOwner notin effectiveOrders:
      effectiveOrders[fleetOwner] = OrderPacket(
        houseId: fleetOwner,
        turn: state.turn,
        fleetCommands: @[],
        buildOrders: @[],
        researchAllocation: res_types_research.initResearchAllocation(),
        diplomaticActions: @[],
        populationTransfers: @[],
        terraformOrders: @[],
        espionageAction: none(esp_types.EspionageAttempt),
        ebpInvestment: 0,
        cipInvestment: 0,
      )

    # Add fleet order to owner's orders
    effectiveOrders[fleetOwner].fleetCommands.add(fleetCommand)
    mergedFleetOrderCount += 1
    logDebug(
      LogCategory.lcOrders,
      &"  [MERGE] {fleetCommand.commandType} from fleet {fleetId} " &
        &"(owner: {fleetOwner})",
    )

  logInfo(
    LogCategory.lcOrders,
    &"Active fleet orders merged " & &"({mergedFleetOrderCount} Conflict Phase orders)",
  )

  # Find all systems where combat should occur based on diplomatic status and orders.
  # Use effectiveOrders (includes merged queued combat orders)
  var combatSystems: seq[SystemId] = @[]

  for systemId, system in state.starMap.systems:
    # Get all houses with active fleets or colonies at this system.
    # Use fleetsByLocation index for O(1) lookup instead of O(F) scan
    var housesPresent: seq[HouseId] = @[]
    if systemId in state.fleetsByLocation:
      for fleetId in state.fleetsByLocation[systemId]:
        if fleetId notin state.fleets:
          continue # Skip stale index entry
        let fleet = state.fleets[fleetId]
        if fleet.owner notin housesPresent:
          housesPresent.add(fleet.owner)
    if systemId in state.colonies and state.colonies[systemId].owner notin housesPresent:
      housesPresent.add(state.colonies[systemId].owner)

    # Need at least two houses to have a conflict.
    if housesPresent.len < 2:
      continue

    var systemHasCombat = false
    for i in 0 ..< housesPresent.len:
      for j in (i + 1) ..< housesPresent.len:
        let house1 = housesPresent[i]
        let house2 = housesPresent[j]

        # Get diplomatic state between these two houses from house1's perspective.
        let relation1to2 =
          state.houses[house1].diplomaticRelations.getDiplomaticState(house2)
        # Get diplomatic state between these two houses from house2's perspective.
        let relation2to1 =
          state.houses[house2].diplomaticRelations.getDiplomaticState(house1)

        # Combat decision logic per docs/engine/mechanics/diplomatic-combat-resolution.md
        if relation1to2 == dip_types.DiplomaticState.Enemy or
            relation2to1 == dip_types.DiplomaticState.Enemy:
          # If either side declares the other 'Enemy', combat occurs.
          systemHasCombat = true
          logDebug(
            LogCategory.lcCombat,
            &"Combat triggered: {house1} vs {house2} (Enemy status)",
          )
        elif relation1to2 == dip_types.DiplomaticState.Hostile or
            relation2to1 == dip_types.DiplomaticState.Hostile:
          # If either side declares 'Hostile', combat occurs if there are ANY threatening or provocative orders
          # from either house in this system.
          var foundProvocativeOrder = false
          for h in @[house1, house2]:
            # Check effective orders (includes queued orders)
            if h in effectiveOrders:
              for command in effectiveOrders[h].fleetCommands:
                # Check if the fleet for this order is actually in the current system
                if command.fleetId in state.fleets and
                    state.fleets[command.fleetId].location == systemId:
                  if isThreateningFleetOrder(command.commandType) or
                      isNonThreateningButProvocativeFleetOrder(command.commandType):
                    foundProvocativeOrder = true
                    break
              if foundProvocativeOrder:
                break

          if foundProvocativeOrder:
            systemHasCombat = true
            logDebug(
              LogCategory.lcCombat,
              &"Combat triggered: {house1} vs {house2} (Hostile status with provocative orders)",
            )
        elif relation1to2 == dip_types.DiplomaticState.Neutral and
            relation2to1 == dip_types.DiplomaticState.Neutral:
          # If both are Neutral, combat only occurs if threatening orders are issued
          # against a system controlled by the other house.
          var house1ThreateningHouse2 = false
          var house2ThreateningHouse1 = false

          # Check if system is controlled (has a colony)
          let systemOwner =
            if systemId in state.colonies:
              some(state.colonies[systemId].owner)
            else:
              none(HouseId)

          # Check effective orders (includes queued orders)
          if house1 in effectiveOrders and systemOwner.isSome and
              systemOwner.get() == house2:
            for command in effectiveOrders[house1].fleetCommands:
              if command.fleetId in state.fleets and
                  state.fleets[command.fleetId].location == systemId and
                  isThreateningFleetOrder(command.commandType):
                house1ThreateningHouse2 = true
                break

          if house2 in effectiveOrders and systemOwner.isSome and
              systemOwner.get() == house1:
            for command in effectiveOrders[house2].fleetCommands:
              if command.fleetId in state.fleets and
                  state.fleets[command.fleetId].location == systemId and
                  isThreateningFleetOrder(command.commandType):
                house2ThreateningHouse1 = true
                break

          if house1ThreateningHouse2 or house2ThreateningHouse1:
            systemHasCombat = true
            logDebug(
              LogCategory.lcCombat,
              &"Combat triggered: {house1} vs {house2} (Neutral status with threatening orders against controlled system)",
            )

        if systemHasCombat:
          break # Found a combat pair, add system and move on.

      if systemHasCombat:
        combatSystems.add(systemId)
        break # System added, move to next system.

  # ===================================================================
  # ARRIVAL FILTERING: Filter orders to only arrived fleets
  # ===================================================================
  # Orders requiring arrival: Bombard, Invade, Blitz, Colonize, SpyPlanet, SpySystem, HackStarbase
  # Create filtered order set once to avoid O(H×O) iteration per step
  var arrivedOrders = effectiveOrders
  for houseId in arrivedOrders.keys:
    var filteredFleetOrders: seq[FleetOrder] = @[]
    for command in arrivedOrders[houseId].fleetCommands:
      # Check if order requires arrival
      const arrivalRequired = [
        FleetCommandType.Bombard, FleetCommandType.Invade, FleetCommandType.Blitz,
        FleetCommandType.Colonize, FleetCommandType.SpyColony,
        FleetCommandType.SpySystem, FleetCommandType.HackStarbase,
      ]
      if command.commandType in arrivalRequired:
        if command.fleetId in state.arrivedFleets:
          filteredFleetOrders.add(command)
        else:
          logDebug(
            LogCategory.lcOrders,
            &"  [SKIP] Fleet {command.fleetId} has not arrived for {command.commandType} order",
          )
      else:
        # Keep orders that don't require arrival checking
        filteredFleetOrders.add(command)
    arrivedOrders[houseId].fleetCommands = filteredFleetOrders

  # ===================================================================
  # STEPS 1, 2, & 4: ALL COMBAT THEATERS (orchestrated)
  # ===================================================================
  # Resolve combat in each system with theater progression enforcement
  # Space → Orbital → Planetary (operations.md:7.0)
  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEPS 1, 2, & 4] Resolving all combat theaters ({combatSystems.len} systems)...",
  )
  for systemId in combatSystems:
    orchestrator.resolveSystemCombat(
      state, systemId, effectiveOrders, arrivedOrders, combatReports, events, rng
    )
  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEPS 1, 2, & 4] Completed ({combatReports.len} battles resolved)",
  )

  # ===================================================================
  # STEP 3: BLOCKADE RESOLUTION
  # ===================================================================
  # Resolve all blockade attempts simultaneously to prevent
  # first-mover advantage
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 3] Resolving blockade attempts...")
  let blockadeResults =
    simultaneous_blockade.resolveBlockades(state, effectiveOrders, rng)
  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEP 3] Completed ({blockadeResults.len} blockade attempts)",
  )

  # Apply blockade results to colonies
  for result in blockadeResults:
    if result.outcome == ResolutionOutcome.Success:
      if result.actualTarget.isSome:
        let targetId = result.actualTarget.get()
        if targetId in state.colonies:
          state.withColony(targetId):
            colony.blockaded = true
            if result.houseId notin colony.blockadedBy:
              colony.blockadedBy.add(result.houseId)
            colony.blockadeTurns += 1
          logInfo(
            "Combat",
            "Blockade established",
            "blockader=",
            $result.houseId,
            " target=",
            $targetId,
          )

  # ===================================================================
  # STEP 4: PLANETARY COMBAT - HANDLED BY ORCHESTRATOR ABOVE
  # ===================================================================
  # Planetary combat is now resolved as part of theater progression in Step 1-2-4
  # The orchestrator enforces Space → Orbital → Planetary sequence
  # No separate call needed here

  # ===================================================================
  # STEP 5: COLONIZATION
  # ===================================================================
  # ETACs establish colonies, resolve conflicts (winner-takes-all)
  # Fallback logic for losers with AutoColonize standing commands
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 5] Resolving colonization attempts...")
  let colonizationResults =
    simultaneous.resolveColonization(state, arrivedOrders, rng, events)
  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEP 5] Completed ({colonizationResults.len} colonization attempts)",
  )

  # Clear arrivedFleets for executed colonization orders
  for result in colonizationResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(
        LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}"
      )

  # ===================================================================
  # STEP 6a: FLEET-BASED ESPIONAGE
  # ===================================================================
  # Resolve fleet-based espionage orders simultaneously
  # Includes Spy Scout detection as part of mission execution
  logInfo(
    LogCategory.lcOrders,
    "[CONFLICT STEP 6a] Fleet-based espionage (SpyPlanet, SpySystem, HackStarbase)...",
  )
  let espionageResults =
    espionage_resolution.resolveEspionage(state, arrivedOrders, rng, events)
  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEP 6a] Completed ({espionageResults.len} fleet espionage attempts)",
  )

  # Clear arrivedFleets for executed espionage orders
  for result in espionageResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(
        LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}"
      )

  # Process scout espionage results and gather intelligence
  # Creates detailed narrative events for espionage reports
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6a] Processing scout intelligence...")
  espionage_resolution.processScoutIntel(
    state, espionageResults, effectiveOrders, rng, events
  )
  logInfo(
    LogCategory.lcOrders, "[CONFLICT STEP 6a] Scout intelligence gathering complete"
  )

  # ===================================================================
  # STEP 6a.5: PERSISTENT SPY MISSION DETECTION
  # ===================================================================
  # Check active spy missions for detection each turn
  logInfo(
    LogCategory.lcOrders, "[CONFLICT STEP 6a.5] Persistent spy mission detection..."
  )
  var missionsToRemove: seq[FleetId] = @[]
  var detectionRng = initRand(state.turn + 98765) # Unique seed for detection

  for fleetId, mission in state.activeSpyMissions.pairs:
    # Skip if fleet no longer exists
    if fleetId notin state.fleets:
      missionsToRemove.add(fleetId)
      continue

    let fleet = state.fleets[fleetId]
    let targetSystem = mission.targetSystem

    # Skip if no defender at target
    if targetSystem notin state.colonies:
      continue

    let colony = state.colonies[targetSystem]
    let defender = colony.owner

    # Run detection check
    let detectionResult = spy_resolution.resolveSpyScoutDetection(
      state, mission.scoutCount, defender, targetSystem, detectionRng
    )

    if detectionResult.detected:
      # DETECTED: Scouts destroyed immediately
      logInfo(
        LogCategory.lcOrders,
        &"Spy mission {fleetId} DETECTED at {targetSystem} (roll={detectionResult.roll}, target={detectionResult.target})",
      )

      # Generate scout detection event
      events.add(
        res_types.GameEvent(
          eventType: res_types.GameEventType.SpyMissionDetected,
          turn: state.turn,
          houseId: some(mission.ownerHouse),
          systemId: some(targetSystem),
          details: some(
            &"Spy mission detected! {mission.scoutCount} scouts destroyed at {targetSystem}"
          ),
        )
      )

      # Diplomatic escalation
      state.scoutLossEvents.add(
        intel_types.ScoutLossEvent(
          turn: state.turn,
          scoutId: $fleetId, # Use fleet ID as scout identifier
          owner: mission.ownerHouse,
          location: targetSystem,
          detectorHouse: defender,
          eventType: intel_types.DetectionEventType.CombatLoss, # Detected spy mission
        )
      )

      # Mark fleet for deletion
      if fleetId in state.fleets:
        let fleet = state.fleets[fleetId]
        state.removeFleetFromIndices(fleetId, fleet.owner, fleet.location)
        state.fleets.del(fleetId)
      missionsToRemove.add(fleetId)

      logInfo(LogCategory.lcOrders, &"Fleet {fleetId} destroyed after detection")
    else:
      # UNDETECTED: Continue gathering intel (generate intelligence this turn)
      logDebug(
        LogCategory.lcOrders,
        &"Spy mission {fleetId} UNDETECTED at {targetSystem} (roll={detectionResult.roll}, target={detectionResult.target})",
      )

      # Generate intelligence based on mission type
      case mission.missionType
      of orders.SpyMissionType.SpyOnPlanet:
        let intelReport = generator.generateColonyIntelReport(
          state, mission.ownerHouse, targetSystem, intel_types.IntelQuality.Perfect
        )
        if intelReport.isSome:
          var house = state.houses[mission.ownerHouse]
          house.intelligence.addColonyReport(intelReport.get())
          state.houses[mission.ownerHouse] = house
          logInfo(
            LogCategory.lcOrders,
            &"Generated Perfect colony intel for {mission.ownerHouse} at {targetSystem}",
          )
      of orders.SpyMissionType.SpyOnSystem:
        let systemIntel = generator.generateSystemIntelReport(
          state, mission.ownerHouse, targetSystem, intel_types.IntelQuality.Perfect
        )
        if systemIntel.isSome:
          var house = state.houses[mission.ownerHouse]
          house.intelligence.addSystemReport(systemIntel.get())
          state.houses[mission.ownerHouse] = house
          logInfo(
            LogCategory.lcOrders,
            &"Generated Perfect system intel for {mission.ownerHouse} at {targetSystem}",
          )
      of orders.SpyMissionType.HackStarbase:
        # For hack starbase, generate perfect colony intel (includes starbase details)
        let intelReport = generator.generateColonyIntelReport(
          state, mission.ownerHouse, targetSystem, intel_types.IntelQuality.Perfect
        )
        if intelReport.isSome:
          var house = state.houses[mission.ownerHouse]
          house.intelligence.addColonyReport(intelReport.get())
          state.houses[mission.ownerHouse] = house
          logInfo(
            LogCategory.lcOrders,
            &"Generated Perfect starbase intel for {mission.ownerHouse} at {targetSystem}",
          )

  # Remove detected/completed missions
  for fleetId in missionsToRemove:
    state.activeSpyMissions.del(fleetId)

  logInfo(
    LogCategory.lcOrders,
    &"[CONFLICT STEP 6a.5] Persistent detection complete ({missionsToRemove.len} missions detected/removed)",
  )

  # ===================================================================
  # STEP 6b: SPACE GUILD ESPIONAGE (EBP-based)
  # ===================================================================
  # Process OrderPacket.espionageAction (EBP-based espionage)
  logInfo(
    LogCategory.lcOrders,
    "[CONFLICT STEP 6b] Space Guild espionage (EBP-based covert ops)...",
  )
  espionage_resolution.processEspionageActions(state, effectiveOrders, rng, events)
  logInfo(
    LogCategory.lcOrders, "[CONFLICT STEP 6b] Completed EBP-based espionage processing"
  )

  # ===================================================================
  # STEP 6c: STARBASE SURVEILLANCE
  # ===================================================================
  # Process starbase surveillance (continuous monitoring every turn)
  # Per Conflict Phase Step 6c: Intelligence gathering happens AFTER combat
  logInfo(
    LogCategory.lcOrders,
    "[CONFLICT STEP 6c] Starbase surveillance (continuous monitoring)...",
  )
  var survRng = initRand(state.turn + 12345) # Unique seed for surveillance
  starbase_surveillance.processAllStarbaseSurveillance(
    state, state.turn, survRng, events
  )
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6c] Completed starbase surveillance")
