## Conflict Phase Resolution - Phase 1 of Canonical Turn Cycle
##
## Resolves all combat and espionage operations for arrived fleets.
## Orders stored in Command Phase execute when fleets arrive at targets.
##
## **Canonical Execution Order:**
##
## 1. Space Combat (simultaneous resolution)
##   1a. Raider Detection
##   1b. Combat Resolution
## 2. Orbital Combat (simultaneous resolution)
##   2a. Raider Detection
##   2b. Combat Resolution
## 3. Blockade Resolution
## 4. Planetary Combat
## 5. Colonization
## 6. Espionage Operations
##   6a. Fleet-Based Espionage (includes Spy Scout Detection)
##   6b. Space Guild Espionage
##   6c. Starbase Surveillance

import std/[tables, options, random, sequtils, strformat]
import ../../../common/types/core
import ../../../common/logger as common_logger
import ../../gamestate, ../../orders, ../../order_types, ../../fleet, ../../squadron, ../../logger, ../../state_helpers
import ../../espionage/[types as esp_types, engine as esp_engine]
import ../../diplomacy/[types as dip_types]
import ../../research/[types as res_types_research]
import ../../intelligence/[spy_resolution, espionage_intel, starbase_surveillance, types as intel_types, generator]
import ../[types as res_types, combat_resolution]
import ../[simultaneous_blockade, simultaneous_planetary, simultaneous_espionage, simultaneous_types, simultaneous]
import ../../prestige as prestige_types
import ../../prestige/application as prestige_app

proc resolveConflictPhase*(state: var GameState, orders: Table[HouseId, OrderPacket],
                          combatReports: var seq[res_types.CombatReport],
                          events: var seq[res_types.GameEvent], rng: var Rand) =
  ## Phase 1: Resolve all combat and infrastructure damage
  ## This happens FIRST so damaged facilities affect production
  logInfo(LogCategory.lcOrders, &"=== Conflict Phase === (turn={state.turn})")
  logInfo(LogCategory.lcOrders, &"Using RNG for combat resolution (seed={state.turn})")

  # Start with current turn orders (will merge state.fleetOrders below)
  var effectiveOrders = orders

  # ===================================================================
  # STEP 0: MERGE ACTIVE FLEET ORDERS (from state.fleetOrders)
  # ===================================================================
  # Per canonical turn cycle: Step 0 merges orders for execution
  # Universal lifecycle: Orders stored in Command Phase (or generated by standing
  # orders in Maintenance Phase) are now merged for Conflict Phase execution.
  # Only merge orders that execute in Conflict Phase (skip Move, Patrol, Salvage).
  logInfo(LogCategory.lcOrders,
          &"[CONFLICT STEP 0] Merging fleet orders for Conflict Phase execution " &
          &"({state.fleetOrders.len} total orders in state)...")

  var mergedFleetOrderCount = 0
  for fleetId, fleetOrder in state.fleetOrders:
    # Only merge orders that execute in Conflict Phase
    # Skip orders that execute in other phases:
    # - Movement orders (Move, Patrol, etc.): Execute in Maintenance Phase
    # - Salvage: Executes in Income Phase
    if fleetOrder.orderType.isMovementOrder() or
       fleetOrder.orderType == FleetOrderType.Salvage:
      continue

    # Find fleet owner
    if fleetId notin state.fleets:
      logDebug(LogCategory.lcOrders,
               &"  [SKIP] Fleet {fleetId} no longer exists")
      continue

    let fleetOwner = state.fleets[fleetId].owner

    # Ensure owner has order packet
    if fleetOwner notin effectiveOrders:
      effectiveOrders[fleetOwner] = OrderPacket(
        houseId: fleetOwner,
        turn: state.turn,
        fleetOrders: @[],
        buildOrders: @[],
        researchAllocation: res_types_research.initResearchAllocation(),
        diplomaticActions: @[],
        populationTransfers: @[],
        terraformOrders: @[],
        espionageAction: none(esp_types.EspionageAttempt),
        ebpInvestment: 0,
        cipInvestment: 0
      )

    # Add fleet order to owner's orders
    effectiveOrders[fleetOwner].fleetOrders.add(fleetOrder)
    mergedFleetOrderCount += 1
    logDebug(LogCategory.lcOrders,
             &"  [MERGE] {fleetOrder.orderType} from fleet {fleetId} " &
             &"(owner: {fleetOwner})")

  logInfo(LogCategory.lcOrders,
          &"Active fleet orders merged " &
          &"({mergedFleetOrderCount} Conflict Phase orders)")

  # Find all systems where combat should occur based on diplomatic status and orders.
  # Use effectiveOrders (includes merged queued combat orders)
  var combatSystems: seq[SystemId] = @[]

  for systemId, system in state.starMap.systems:
    # Get all houses with active fleets or colonies at this system.
    var housesPresent: seq[HouseId] = @[]
    for fleet in state.fleets.values:
      if fleet.location == systemId and fleet.owner notin housesPresent:
        housesPresent.add(fleet.owner)
    if systemId in state.colonies and state.colonies[systemId].owner notin housesPresent:
      housesPresent.add(state.colonies[systemId].owner)

    # Need at least two houses to have a conflict.
    if housesPresent.len < 2:
      continue

    var systemHasCombat = false
    for i in 0..<housesPresent.len:
      for j in (i+1)..<housesPresent.len:
        let house1 = housesPresent[i]
        let house2 = housesPresent[j]

        # Get diplomatic state between these two houses from house1's perspective.
        let relation1to2 = state.houses[house1].diplomaticRelations.getDiplomaticState(house2)
        # Get diplomatic state between these two houses from house2's perspective.
        let relation2to1 = state.houses[house2].diplomaticRelations.getDiplomaticState(house1)

        # Combat decision logic per docs/engine/mechanics/diplomatic-combat-resolution.md
        if relation1to2 == dip_types.DiplomaticState.Enemy or
           relation2to1 == dip_types.DiplomaticState.Enemy:
          # If either side declares the other 'Enemy', combat occurs.
          systemHasCombat = true
          logDebug(LogCategory.lcCombat, &"Combat triggered: {house1} vs {house2} (Enemy status)")
        elif relation1to2 == dip_types.DiplomaticState.Hostile or
             relation2to1 == dip_types.DiplomaticState.Hostile:
          # If either side declares 'Hostile', combat occurs if there are ANY threatening or provocative orders
          # from either house in this system.
          var foundProvocativeOrder = false
          for h in @[house1, house2]:
            # Check effective orders (includes queued orders)
            if h in effectiveOrders:
              for order in effectiveOrders[h].fleetOrders:
                # Check if the fleet for this order is actually in the current system
                if order.fleetId in state.fleets and state.fleets[order.fleetId].location == systemId:
                  if order.orderType.isThreateningFleetOrder() or order.orderType.isNonThreateningButProvocativeFleetOrder():
                    foundProvocativeOrder = true
                    break
              if foundProvocativeOrder:
                break

          if foundProvocativeOrder:
            systemHasCombat = true
            logDebug(LogCategory.lcCombat, &"Combat triggered: {house1} vs {house2} (Hostile status with provocative orders)")
        elif relation1to2 == dip_types.DiplomaticState.Neutral and
             relation2to1 == dip_types.DiplomaticState.Neutral:
          # If both are Neutral, combat only occurs if threatening orders are issued
          # against a system controlled by the other house.
          var house1ThreateningHouse2 = false
          var house2ThreateningHouse1 = false

          # Check if system is controlled (has a colony)
          let systemOwner = if systemId in state.colonies: some(state.colonies[systemId].owner) else: none(HouseId)

          # Check effective orders (includes queued orders)
          if house1 in effectiveOrders and systemOwner.isSome and systemOwner.get() == house2:
            for order in effectiveOrders[house1].fleetOrders:
              if order.fleetId in state.fleets and state.fleets[order.fleetId].location == systemId and order.orderType.isThreateningFleetOrder():
                house1ThreateningHouse2 = true
                break

          if house2 in effectiveOrders and systemOwner.isSome and systemOwner.get() == house1:
            for order in effectiveOrders[house2].fleetOrders:
              if order.fleetId in state.fleets and state.fleets[order.fleetId].location == systemId and order.orderType.isThreateningFleetOrder():
                house2ThreateningHouse1 = true
                break

          if house1ThreateningHouse2 or house2ThreateningHouse1:
            systemHasCombat = true
            logDebug(LogCategory.lcCombat, &"Combat triggered: {house1} vs {house2} (Neutral status with threatening orders against controlled system)")

        if systemHasCombat:
          break # Found a combat pair, add system and move on.

      if systemHasCombat:
        combatSystems.add(systemId)
        break # System added, move to next system.

  # ===================================================================
  # STEPS 1 & 2: SPACE & ORBITAL COMBAT
  # ===================================================================
  # Resolve combat in each system (operations.md:7.0)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEPS 1 & 2] Resolving space/orbital combat ({combatSystems.len} systems)...")
  for systemId in combatSystems:
    resolveBattle(state, systemId, effectiveOrders, combatReports, events, rng)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEPS 1 & 2] Completed ({combatReports.len} battles resolved)")

  # ===================================================================
  # ARRIVAL FILTERING: Filter orders to only arrived fleets
  # ===================================================================
  # Orders requiring arrival: Bombard, Invade, Blitz, Colonize, SpyPlanet, SpySystem, HackStarbase
  # Create filtered order set once to avoid O(HÃ—O) iteration per step
  var arrivedOrders = effectiveOrders
  for houseId in arrivedOrders.keys:
    var filteredFleetOrders: seq[FleetOrder] = @[]
    for order in arrivedOrders[houseId].fleetOrders:
      # Check if order requires arrival
      const arrivalRequired = [
        FleetOrderType.Bombard, FleetOrderType.Invade, FleetOrderType.Blitz,
        FleetOrderType.Colonize,
        FleetOrderType.SpyPlanet, FleetOrderType.SpySystem, FleetOrderType.HackStarbase
      ]
      if order.orderType in arrivalRequired:
        if order.fleetId in state.arrivedFleets:
          filteredFleetOrders.add(order)
        else:
          logDebug(LogCategory.lcOrders, &"  [SKIP] Fleet {order.fleetId} has not arrived for {order.orderType} order")
      else:
        # Keep orders that don't require arrival checking
        filteredFleetOrders.add(order)
    arrivedOrders[houseId].fleetOrders = filteredFleetOrders

  # ===================================================================
  # STEP 3: BLOCKADE RESOLUTION
  # ===================================================================
  # Resolve all blockade attempts simultaneously to prevent
  # first-mover advantage
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 3] Resolving blockade attempts...")
  let blockadeResults = simultaneous_blockade.resolveBlockades(state,
                                                                effectiveOrders,
                                                                rng)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 3] Completed ({blockadeResults.len} blockade attempts)")

  # Apply blockade results to colonies
  for result in blockadeResults:
    if result.outcome == ResolutionOutcome.Success:
      if result.actualTarget.isSome:
        let targetId = result.actualTarget.get()
        if targetId in state.colonies:
          state.withColony(targetId):
            colony.blockaded = true
            if result.houseId notin colony.blockadedBy:
              colony.blockadedBy.add(result.houseId)
            colony.blockadeTurns += 1
          logInfo("Combat", "Blockade established",
                  "blockader=", $result.houseId, " target=", $targetId)

  # ===================================================================
  # STEP 4: PLANETARY COMBAT RESOLUTION
  # ===================================================================
  # Resolve all planetary combat (bombard/invade/blitz) simultaneously
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 4] Resolving planetary combat...")
  let planetaryCombatResults = simultaneous_planetary.resolvePlanetaryCombat(
    state, arrivedOrders, rng, events)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 4] Completed ({planetaryCombatResults.len} planetary combat attempts)")

  # Clear arrivedFleets for executed planetary combat orders
  for result in planetaryCombatResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}")

  # ===================================================================
  # STEP 5: COLONIZATION
  # ===================================================================
  # ETACs establish colonies, resolve conflicts (winner-takes-all)
  # Fallback logic for losers with AutoColonize standing orders
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 5] Resolving colonization attempts...")
  let colonizationResults = simultaneous.resolveColonization(
    state, arrivedOrders, rng, events)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 5] Completed ({colonizationResults.len} colonization attempts)")

  # Clear arrivedFleets for executed colonization orders
  for result in colonizationResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}")

  # ===================================================================
  # STEP 6a: FLEET-BASED ESPIONAGE
  # ===================================================================
  # Resolve fleet-based espionage orders simultaneously
  # Includes Spy Scout detection as part of mission execution
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6a] Fleet-based espionage (SpyPlanet, SpySystem, HackStarbase)...")
  let espionageResults = simultaneous_espionage.resolveEspionage(state,
                                                                  arrivedOrders, rng, events)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 6a] Completed ({espionageResults.len} fleet espionage attempts)")

  # Clear arrivedFleets for executed espionage orders
  for result in espionageResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}")

  # Process scout espionage results and gather intelligence
  # Creates detailed narrative events for espionage reports
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6a] Processing scout intelligence...")
  simultaneous_espionage.processScoutIntelligence(state, espionageResults,
                                                   effectiveOrders, rng, events)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6a] Scout intelligence gathering complete")

  # ===================================================================
  # STEP 6a.5: PERSISTENT SPY MISSION DETECTION
  # ===================================================================
  # Check active spy missions for detection each turn
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6a.5] Persistent spy mission detection...")
  var missionsToRemove: seq[FleetId] = @[]
  var detectionRng = initRand(state.turn + 98765)  # Unique seed for detection

  for fleetId, mission in state.activeSpyMissions.pairs:
    # Skip if fleet no longer exists
    if fleetId notin state.fleets:
      missionsToRemove.add(fleetId)
      continue

    let fleet = state.fleets[fleetId]
    let targetSystem = mission.targetSystem

    # Skip if no defender at target
    if targetSystem notin state.colonies:
      continue

    let colony = state.colonies[targetSystem]
    let defender = colony.owner

    # Run detection check
    let detectionResult = spy_resolution.resolveSpyScoutDetection(
      state,
      mission.scoutCount,
      defender,
      targetSystem,
      detectionRng
    )

    if detectionResult.detected:
      # DETECTED: Scouts destroyed immediately
      logInfo(LogCategory.lcOrders, &"Spy mission {fleetId} DETECTED at {targetSystem} (roll={detectionResult.roll}, target={detectionResult.target})")

      # Generate scout detection event
      events.add(res_types.GameEvent(
        eventType: res_types.GameEventType.ScoutDetected,
        turn: state.turn,
        houseId: some(mission.ownerHouse),
        systemId: some(targetSystem),
        details: some(&"Spy mission detected! {mission.scoutCount} scouts destroyed at {targetSystem}")
      ))

      # Diplomatic escalation
      state.scoutLossEvents.add(intel_types.ScoutLossEvent(
        turn: state.turn,
        scoutId: fleetId,  # Use fleet ID as scout identifier
        owner: mission.ownerHouse,
        location: targetSystem,
        detectorHouse: defender,
        eventType: intel_types.DetectionEventType.CombatLoss  # Detected spy mission
      ))

      # Mark fleet for deletion
      if fleetId in state.fleets:
        state.fleets.del(fleetId)
      missionsToRemove.add(fleetId)

      logInfo(LogCategory.lcOrders, &"Fleet {fleetId} destroyed after detection")
    else:
      # UNDETECTED: Continue gathering intel (generate intelligence this turn)
      logDebug(LogCategory.lcOrders, &"Spy mission {fleetId} UNDETECTED at {targetSystem} (roll={detectionResult.roll}, target={detectionResult.target})")

      # Generate intelligence based on mission type
      case mission.missionType
      of SpyMissionType.SpyOnPlanet:
        let intelReport = generator.generateColonyIntelReport(state, mission.ownerHouse, targetSystem, intel_types.IntelQuality.Perfect)
        if intelReport.isSome:
          var house = state.houses[mission.ownerHouse]
          house.intelligence.addColonyReport(intelReport.get())
          state.houses[mission.ownerHouse] = house
          logInfo(LogCategory.lcOrders, &"Generated Perfect colony intel for {mission.ownerHouse} at {targetSystem}")

      of SpyMissionType.SpyOnSystem:
        let systemIntel = generator.generateSystemIntelReport(state, mission.ownerHouse, targetSystem, intel_types.IntelQuality.Perfect)
        if systemIntel.isSome:
          var house = state.houses[mission.ownerHouse]
          house.intelligence.addSystemReport(systemIntel.get())
          state.houses[mission.ownerHouse] = house
          logInfo(LogCategory.lcOrders, &"Generated Perfect system intel for {mission.ownerHouse} at {targetSystem}")

      of SpyMissionType.HackStarbase:
        # For hack starbase, generate perfect colony intel (includes starbase details)
        let intelReport = generator.generateColonyIntelReport(state, mission.ownerHouse, targetSystem, intel_types.IntelQuality.Perfect)
        if intelReport.isSome:
          var house = state.houses[mission.ownerHouse]
          house.intelligence.addColonyReport(intelReport.get())
          state.houses[mission.ownerHouse] = house
          logInfo(LogCategory.lcOrders, &"Generated Perfect starbase intel for {mission.ownerHouse} at {targetSystem}")

  # Remove detected/completed missions
  for fleetId in missionsToRemove:
    state.activeSpyMissions.del(fleetId)

  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 6a.5] Persistent detection complete ({missionsToRemove.len} missions detected/removed)")

  # ===================================================================
  # STEP 6b: SPACE GUILD ESPIONAGE (EBP-based)
  # ===================================================================
  # Process OrderPacket.espionageAction (EBP-based espionage)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6b] Space Guild espionage (EBP-based covert ops)...")
  simultaneous_espionage.processEspionageActions(state, effectiveOrders, rng, events)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6b] Completed EBP-based espionage processing")

  # ===================================================================
  # STEP 6c: STARBASE SURVEILLANCE
  # ===================================================================
  # Process starbase surveillance (continuous monitoring every turn)
  # Per Conflict Phase Step 6c: Intelligence gathering happens AFTER combat
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6c] Starbase surveillance (continuous monitoring)...")
  var survRng = initRand(state.turn + 12345)  # Unique seed for surveillance
  starbase_surveillance.processAllStarbaseSurveillance(state, state.turn, survRng)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6c] Completed starbase surveillance")

