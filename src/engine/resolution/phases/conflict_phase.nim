## Conflict Phase Resolution - Phase 1 of Canonical Turn Cycle
##
## Resolves all combat and espionage operations for arrived fleets.
## Orders stored in Command Phase execute when fleets arrive at targets.
##
## **Canonical Execution Order:**
##
## Step 1: Space Combat (simultaneous resolution)
## Step 2: Orbital Combat (simultaneous resolution)
## Step 3: Blockade Resolution (simultaneous resolution)
## Step 4: Planetary Combat (sequential execution, simultaneous priority)
## Step 5: Colonization (simultaneous resolution)
## Step 6: Espionage Operations (simultaneous resolution)
##   6a. Spy Scout Detection (pre-combat preparation)
##   6b. Fleet-Based Espionage (SpyPlanet, SpySystem, HackStarbase)
##   6c. Space Guild Espionage (EBP-based covert ops)
##   6d. Starbase Surveillance (continuous monitoring)
##
## **Implementation Note:**
## Spy detection (Step 6a) executes BEFORE combat (line 49-53) to exclude
## detected scouts from participating in battles. All other espionage operations
## execute AFTER combat to gather post-battle intelligence.

import std/[tables, options, random, sequtils, strformat]
import ../../../common/types/core
import ../../../common/logger as common_logger
import ../../gamestate, ../../orders, ../../order_types, ../../fleet, ../../squadron, ../../logger, ../../state_helpers
import ../../espionage/[types as esp_types, engine as esp_engine]
import ../../diplomacy/[types as dip_types]
import ../../research/[types as res_types_research]
import ../../intelligence/[spy_travel, spy_resolution, espionage_intel, starbase_surveillance]
import ../[types as res_types, combat_resolution]
import ../[simultaneous_blockade, simultaneous_planetary, simultaneous_espionage, simultaneous_types, simultaneous]
import ../../prestige as prestige_types
import ../../prestige/application as prestige_app

proc resolveConflictPhase*(state: var GameState, orders: Table[HouseId, OrderPacket],
                          combatReports: var seq[res_types.CombatReport],
                          events: var seq[res_types.GameEvent], rng: var Rand) =
  ## Phase 1: Resolve all combat and infrastructure damage
  ## This happens FIRST so damaged facilities affect production
  logInfo(LogCategory.lcOrders, &"=== Conflict Phase === (turn={state.turn})")
  logInfo(LogCategory.lcOrders, &"Using RNG for combat resolution (seed={state.turn})")

  # Start with current turn orders (will merge state.fleetOrders below)
  var effectiveOrders = orders

  # ===================================================================
  # MERGE ACTIVE FLEET ORDERS (from state.fleetOrders)
  # ===================================================================
  # Universal lifecycle: Orders stored in Command Phase (or generated by standing
  # orders in Maintenance Phase) are now merged for Conflict Phase execution.
  # Only merge orders that execute in Conflict Phase (skip Move, Patrol, Salvage).
  logInfo(LogCategory.lcOrders,
          &"Merging fleet orders for Conflict Phase execution " &
          &"({state.fleetOrders.len} total orders in state)...")

  var mergedFleetOrderCount = 0
  for fleetId, fleetOrder in state.fleetOrders:
    # Only merge orders that execute in Conflict Phase
    # Skip orders that execute in other phases:
    # - Movement orders (Move, Patrol, etc.): Execute in Maintenance Phase
    # - Salvage: Executes in Income Phase
    if fleetOrder.orderType.isMovementOrder() or
       fleetOrder.orderType == FleetOrderType.Salvage:
      continue

    # Find fleet owner
    if fleetId notin state.fleets:
      logDebug(LogCategory.lcOrders,
               &"  [SKIP] Fleet {fleetId} no longer exists")
      continue

    let fleetOwner = state.fleets[fleetId].owner

    # Ensure owner has order packet
    if fleetOwner notin effectiveOrders:
      effectiveOrders[fleetOwner] = OrderPacket(
        houseId: fleetOwner,
        turn: state.turn,
        fleetOrders: @[],
        buildOrders: @[],
        researchAllocation: res_types_research.initResearchAllocation(),
        diplomaticActions: @[],
        populationTransfers: @[],
        terraformOrders: @[],
        espionageAction: none(esp_types.EspionageAttempt),
        ebpInvestment: 0,
        cipInvestment: 0
      )

    # Add fleet order to owner's orders
    effectiveOrders[fleetOwner].fleetOrders.add(fleetOrder)
    mergedFleetOrderCount += 1
    logDebug(LogCategory.lcOrders,
             &"  [MERGE] {fleetOrder.orderType} from fleet {fleetId} " &
             &"(owner: {fleetOwner})")

  logInfo(LogCategory.lcOrders,
          &"Active fleet orders merged " &
          &"({mergedFleetOrderCount} Conflict Phase orders)")

  # ===================================================================
  # STEP 6a: SPY SCOUT DETECTION (Pre-Combat Prep)
  # ===================================================================
  # Resolve spy scout detection BEFORE combat
  # Spy scouts that go undetected remain hidden and don't participate in combat
  # Per assets.md:2.4.2 - detection checks occur each turn for active spy scouts
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6a] Spy scout detection (pre-combat prep)...")
  let detectionResults = spy_resolution.resolveSpyDetection(state, events)
  for msg in detectionResults:
    logInfo("Intelligence", "Spy detection", msg)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 6a] Completed ({detectionResults.len} detection checks)")

  # Find all systems where combat should occur based on diplomatic status and orders.
  # Use effectiveOrders (includes merged queued combat orders)
  var combatSystems: seq[SystemId] = @[]

  for systemId, system in state.starMap.systems:
    # Get all houses with active fleets or colonies at this system.
    var housesPresent: seq[HouseId] = @[]
    for fleet in state.fleets.values:
      if fleet.location == systemId and fleet.owner notin housesPresent:
        housesPresent.add(fleet.owner)
    if systemId in state.colonies and state.colonies[systemId].owner notin housesPresent:
      housesPresent.add(state.colonies[systemId].owner)

    # Need at least two houses to have a conflict.
    if housesPresent.len < 2:
      continue

    var systemHasCombat = false
    for i in 0..<housesPresent.len:
      for j in (i+1)..<housesPresent.len:
        let house1 = housesPresent[i]
        let house2 = housesPresent[j]

        # Get diplomatic state between these two houses from house1's perspective.
        let relation1to2 = state.houses[house1].diplomaticRelations.getDiplomaticState(house2)
        # Get diplomatic state between these two houses from house2's perspective.
        let relation2to1 = state.houses[house2].diplomaticRelations.getDiplomaticState(house1)

        # Combat decision logic per docs/engine/mechanics/diplomatic-combat-resolution.md
        if relation1to2 == dip_types.DiplomaticState.Enemy or
           relation2to1 == dip_types.DiplomaticState.Enemy:
          # If either side declares the other 'Enemy', combat occurs.
          systemHasCombat = true
          logDebug(LogCategory.lcCombat, &"Combat triggered: {house1} vs {house2} (Enemy status)")
        elif relation1to2 == dip_types.DiplomaticState.Hostile or
             relation2to1 == dip_types.DiplomaticState.Hostile:
          # If either side declares 'Hostile', combat occurs if there are ANY threatening or provocative orders
          # from either house in this system.
          var foundProvocativeOrder = false
          for h in @[house1, house2]:
            # Check effective orders (includes queued orders)
            if h in effectiveOrders:
              for order in effectiveOrders[h].fleetOrders:
                # Check if the fleet for this order is actually in the current system
                if order.fleetId in state.fleets and state.fleets[order.fleetId].location == systemId:
                  if order.orderType.isThreateningFleetOrder() or order.orderType.isNonThreateningButProvocativeFleetOrder():
                    foundProvocativeOrder = true
                    break
              if foundProvocativeOrder:
                break

          if foundProvocativeOrder:
            systemHasCombat = true
            logDebug(LogCategory.lcCombat, &"Combat triggered: {house1} vs {house2} (Hostile status with provocative orders)")
        elif relation1to2 == dip_types.DiplomaticState.Neutral and
             relation2to1 == dip_types.DiplomaticState.Neutral:
          # If both are Neutral, combat only occurs if threatening orders are issued
          # against a system controlled by the other house.
          var house1ThreateningHouse2 = false
          var house2ThreateningHouse1 = false

          # Check if system is controlled (has a colony)
          let systemOwner = if systemId in state.colonies: some(state.colonies[systemId].owner) else: none(HouseId)

          # Check effective orders (includes queued orders)
          if house1 in effectiveOrders and systemOwner.isSome and systemOwner.get() == house2:
            for order in effectiveOrders[house1].fleetOrders:
              if order.fleetId in state.fleets and state.fleets[order.fleetId].location == systemId and order.orderType.isThreateningFleetOrder():
                house1ThreateningHouse2 = true
                break

          if house2 in effectiveOrders and systemOwner.isSome and systemOwner.get() == house1:
            for order in effectiveOrders[house2].fleetOrders:
              if order.fleetId in state.fleets and state.fleets[order.fleetId].location == systemId and order.orderType.isThreateningFleetOrder():
                house2ThreateningHouse1 = true
                break

          if house1ThreateningHouse2 or house2ThreateningHouse1:
            systemHasCombat = true
            logDebug(LogCategory.lcCombat, &"Combat triggered: {house1} vs {house2} (Neutral status with threatening orders against controlled system)")

        if systemHasCombat:
          break # Found a combat pair, add system and move on.

      if systemHasCombat:
        combatSystems.add(systemId)
        break # System added, move to next system.

  # ===================================================================
  # STEPS 1 & 2: SPACE & ORBITAL COMBAT
  # ===================================================================
  # Resolve combat in each system (operations.md:7.0)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEPS 1 & 2] Resolving space/orbital combat ({combatSystems.len} systems)...")
  for systemId in combatSystems:
    resolveBattle(state, systemId, effectiveOrders, combatReports, events, rng)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEPS 1 & 2] Completed ({combatReports.len} battles resolved)")

  # ===================================================================
  # ARRIVAL FILTERING: Filter orders to only arrived fleets
  # ===================================================================
  # Orders requiring arrival: Bombard, Invade, Blitz, Colonize, SpyPlanet, SpySystem, HackStarbase
  # Create filtered order set once to avoid O(HÃ—O) iteration per step
  var arrivedOrders = effectiveOrders
  for houseId in arrivedOrders.keys:
    var filteredFleetOrders: seq[FleetOrder] = @[]
    for order in arrivedOrders[houseId].fleetOrders:
      # Check if order requires arrival
      const arrivalRequired = [
        FleetOrderType.Bombard, FleetOrderType.Invade, FleetOrderType.Blitz,
        FleetOrderType.Colonize,
        FleetOrderType.SpyPlanet, FleetOrderType.SpySystem, FleetOrderType.HackStarbase
      ]
      if order.orderType in arrivalRequired:
        if order.fleetId in state.arrivedFleets:
          filteredFleetOrders.add(order)
        else:
          logDebug(LogCategory.lcOrders, &"  [SKIP] Fleet {order.fleetId} has not arrived for {order.orderType} order")
      else:
        # Keep orders that don't require arrival checking
        filteredFleetOrders.add(order)
    arrivedOrders[houseId].fleetOrders = filteredFleetOrders

  # ===================================================================
  # STEP 3: BLOCKADE RESOLUTION
  # ===================================================================
  # Resolve all blockade attempts simultaneously to prevent
  # first-mover advantage
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 3] Resolving blockade attempts...")
  let blockadeResults = simultaneous_blockade.resolveBlockades(state,
                                                                effectiveOrders,
                                                                rng)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 3] Completed ({blockadeResults.len} blockade attempts)")

  # Apply blockade results to colonies
  for result in blockadeResults:
    if result.outcome == ResolutionOutcome.Success:
      if result.actualTarget.isSome:
        let targetId = result.actualTarget.get()
        if targetId in state.colonies:
          state.withColony(targetId):
            colony.blockaded = true
            if result.houseId notin colony.blockadedBy:
              colony.blockadedBy.add(result.houseId)
            colony.blockadeTurns += 1
          logInfo("Combat", "Blockade established",
                  "blockader=", $result.houseId, " target=", $targetId)

  # ===================================================================
  # STEP 4: PLANETARY COMBAT RESOLUTION
  # ===================================================================
  # Resolve all planetary combat (bombard/invade/blitz) simultaneously
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 4] Resolving planetary combat...")
  let planetaryCombatResults = simultaneous_planetary.resolvePlanetaryCombat(
    state, arrivedOrders, rng, events)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 4] Completed ({planetaryCombatResults.len} planetary combat attempts)")

  # Clear arrivedFleets for executed planetary combat orders
  for result in planetaryCombatResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}")

  # ===================================================================
  # STEP 5: COLONIZATION
  # ===================================================================
  # ETACs establish colonies, resolve conflicts (winner-takes-all)
  # Fallback logic for losers with AutoColonize standing orders
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 5] Resolving colonization attempts...")
  let colonizationResults = simultaneous.resolveColonization(
    state, arrivedOrders, rng, events)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 5] Completed ({colonizationResults.len} colonization attempts)")

  # Clear arrivedFleets for executed colonization orders
  for result in colonizationResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}")

  # ===================================================================
  # STEP 6b: FLEET-BASED ESPIONAGE
  # ===================================================================
  # Resolve fleet-based espionage orders simultaneously
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6b] Fleet-based espionage (SpyPlanet, SpySystem, HackStarbase)...")
  let espionageResults = simultaneous_espionage.resolveEspionage(state,
                                                                  arrivedOrders, rng)
  logInfo(LogCategory.lcOrders, &"[CONFLICT STEP 6b] Completed ({espionageResults.len} fleet espionage attempts)")

  # Clear arrivedFleets for executed espionage orders
  for result in espionageResults:
    if result.fleetId in state.arrivedFleets:
      state.arrivedFleets.del(result.fleetId)
      logDebug(LogCategory.lcOrders, &"  Cleared arrival status for fleet {result.fleetId}")

  # Process scout espionage results and gather intelligence
  # Creates detailed narrative events for espionage reports
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6b] Processing scout intelligence...")
  simultaneous_espionage.processScoutIntelligence(state, espionageResults,
                                                   effectiveOrders, rng, events)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6b] Scout intelligence gathering complete")

  # ===================================================================
  # STEP 6c: SPACE GUILD ESPIONAGE (EBP-based)
  # ===================================================================
  # Process OrderPacket.espionageAction (EBP-based espionage)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6c] Space Guild espionage (EBP-based covert ops)...")
  simultaneous_espionage.processEspionageActions(state, effectiveOrders, rng, events)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6c] Completed EBP-based espionage processing")

  # ===================================================================
  # STEP 6d: STARBASE SURVEILLANCE
  # ===================================================================
  # Process starbase surveillance (continuous monitoring every turn)
  # Per Conflict Phase Step 6d: Intelligence gathering happens AFTER combat
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6d] Starbase surveillance (continuous monitoring)...")
  var survRng = initRand(state.turn + 12345)  # Unique seed for surveillance
  starbase_surveillance.processAllStarbaseSurveillance(state, state.turn, survRng)
  logInfo(LogCategory.lcOrders, "[CONFLICT STEP 6d] Completed starbase surveillance")

